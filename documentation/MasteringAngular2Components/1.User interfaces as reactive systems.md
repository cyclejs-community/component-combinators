# User interface programming
That is reactive paradigm almost by nature. So :

- `action = f(event)`, where
	- event is an event triggering an action by the user interface. Events can be
		- user-initiated
		- system-initiated i.e. generated by the environment or external world

INSERT example

Because most reactive systems are stateful, the `f` function presented here is not pure :

INSERT example

Hence what we have is `(action, new state) = f(state, event)` where :

- `f` is a pure function
- `state` contains all the variability resulting from the environment and the reactive systems specifications, so that `f` is pure

INSERT example

If we index time chronologically by a natural integer, so that the index `n` correspond to the nth event occurring, we have `(action_n+1, state_n+1) = f(state_n, event_n)` where :

- `action_0` is undefined
- `n` is the `nth` event processed by the reactive system
- `state_n ` is the state of the reactive system **when the `nth` event is processed**
	- we hence have an implicit time relation here between the event occurrence and the state used to compute the reaction of the system.

By using streams to represent sequences over time, the equation is rewrote as `(actions, next(states, events)) = f(states, events)` where :
- f is a pure function
- `next` is derived from the reactive system's specification
	- i.e. specifying how the state of the reactive system changes in response to an event
- `states` is a sequence where each value is the corresponding state of the reactive system at the time when an event is triggered, and subject to the equation :
	- `next(states, events) ` is such that :
		- `states[n] =def= next(states[n-1], events[n-1])`

The `states` stream hence has a recursive definition. Lazily-evaluated languages will allow for expressing `states` quite naturally as a fixed point for `x -> next(x, events)`, while eagerly-evaluated  languages will require extra wrapping.

From there, there are three interesting ways to write the equations specifying the behavior of the reactive system, which can be associated to different implementation approachs.
 
The first rewrite is also the most immediate from the previous formulation. Assuming the function `next` have been determined, the reactive system behaviour is then entirely described by the following equations, which are those corresponding to a [state transducer](http://www.cse.chalmers.se/~coquand/AUTOMATA/book.pdf)(cf. p.479) :

- `states = next(states, events)`
	- `next` will be termed here as the state transition function
- `actions = f(states, events)`, for a convenient `f`
	- `f` will be termed here as the reactive function

State transducers are state machines, which have an internal state, and on receiving an input, they may produce an output and update their internal state. This opens the path to implementing reactive systems with state machines. The reference here is <em>Programming reactive systems with state charts</em> by David Harel.

The second rewrite takes the product of the reactive function and the state transition, resulting in a new reactive function which also returns the next state of the system. That is :

- `(actions, states) = f(states, events)`
- `states` is as before a fixed point for a convenient function
- `f` is a pure function

This is the model followed for example by `Elm`, whose `update :: Msg -> Model -> (Model, Cmd Msg)` function corresponds closely to the reactive function `f`, `Msg` to `events`, `Model` to `states`, `Cmd Msg` to `actions`. The same model can also be found in other reactive frameworks for functional languages (purescript/[pux](http://purescript-pux.org/docs/architecture/) with `foldp :: âˆ€ fx. Event -> State -> EffModel State Event fx`).

The third rewrite collapses the state transition into the reactive function, by considering that state change is itself an action. A reactive system behavior can then be entirely described by a quadruplet `{f, actions, states, events}` such that :

- `actions = f(states, events)`
- actions which update the state must happen before the next event is processed by the system[^instant_state_update]
- `f` is a pure function

[^instant_state_update]: so that we maintain `states[n] =def= next(states[n-1], events[n-1])`. If the nth event would be processed before `state[n]` is set through the equation, the `next` function could be computing an invalid state for the reactive system.

This is the model followed in particular by `cycle.js`, where `App :: Sources -> Sinks`, where `Sources` contains any necessary accessor/factory methods for the state of the system and 
events admitted by the system, and `Sinks` holds the actions triggered by the events.

In any case, specifying and implementing a reactive system can be reduced to eliciting and implementing a pure reactive function.

INSERT example

In practice, the function `f` is complex, exactly as complex as the reactive system to implement. While the objective complexity (also coined essential complexity in the software domain) of `f` cannot be changed, the subjective complexity which is related to our ability to handle that objective complexity will be a function of the abstractions, and techniques we have at our disposal. In the software domain, accidental complexity is defined as the complexity that an implementation approach adds to the essential complexity corresponding to the specification of a system. Here are a few techniques used for reducing accidental complexity :

- Abstractions
	- domain : domain modeling
	- storage : databases
	- asynchrony : streams (!!)
	- memory : garbage collector, constructors
	- etc.
- Techniques
	- functional programming
	- componentization
	- xxx programming (xxx in {object-oriented, aspect-oriented, declarative, and other buzz words})
	- model-based testing
	- TDD
	- etc.

In the current state of my knowledge, I believe that the most effective levers in mastering complexity are domain modelling, functional programming, and componentization. If we deal with reactive systems, then we need to add reactive programming to that mix. 

We will address in what follows componentization.
