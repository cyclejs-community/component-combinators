# Componentization
## Abstractions against complexity
We have previously seen that a reactive system can be described by equations involving a reactive function `f` such that `actions = f(state, events)`. In theory, the function `f` is as complex as the specification of the reactive system to implement. In practice, it is often much more so, as dictated by the particular implementation choices made.

Complexity resists to a uniformally useful definition. However, it is generally accepted that there is a component of complexity which cannot be reduced by any particular technique. 'How many systems do we have? In what convoluted manner are they connected? What the requirement for operating these systems? How many parameters or subtasks are necessary to specify a task?'. That complexity increases every year, as the trend is into interconnecting more and more systens to satisfy ever astringent user requirements to do more things in less time. To reuse a commonly used term, we will call this the essential complexity of the system under specification.

Oddly enough, at the same time, on a subjective level, things that were complex last year are less complex now. That subjective but very real component of complexity relates the number of things that cause problems to our ability to deal with them. Our ability to deal with them goes up as we develop better languages, tools, interfaces, architecture, infrastracture, etc. and are able to do more with less. We would define this component of complexity as accidental complexity, and as being the complexity that an implementation approach adds to the essential complexity corresponding to the specification of a system.

As a side note, a user interface itself is precisely an attempt at shielding the user from the complexity of underlying systems so he can focus on the domain at hand and the tasks it encompasses. In other words, the user interface **abstracts** out the underlying system layer. As a matter of fact, most advances against accidental complexity (in **any** field) are made by better and/or more powerful abstractions.

We can list a range of abstractions taking aim at specific sources of complexity, at the system implementation level : 

- domain : domain modeling
- implementation language : domain-specific language
- storage : databases
- asynchrony : streams (!!)
- memory : garbage collector, constructors
- testing : model-based testing 
- design : componentization
- programming paradigm : declarative programming (including functional programming, dataflow programming, logic programming)  

In the current state of my knowledge, I believe that the most effective levers in mastering complexity are domain modelling, domain-specific languages, and components, glued together by means of declarative programming. 

We will address in what follows componentization.

## What is componentization
The major goal in software construction is to build software that are robust (i.e. performs correctly and does not crash even in unforeseen cases), flexible (i.e. can be used in many seemingly different applications), extensible (i.e. can be extended with minimal if not no modification of existing code), easy to maintain (i.e. to modify to improve performance or fix "bugs"). The main tool of the trade of software developers can be summarized in one word: abstraction.

The abstraction process involves several steps:

- Eliminate all unnecessary details and get to the essential elements of the problem and express them clearly and concisely as invariants.
- Encapsulate that which vary and express them as variants.  The variants of abstractly equivalent behaviors are grouped into appropriate taxonomy of abstract classes and subclasses.
- Define the dynamics of the system in terms of the  interplay between the invariants and the variants.  Sometime the invariants/variants interplays can be straightforward, but more than often they can be subtle like the case when an invariant can be expressed in terms of many variants.

The effort spent in identifying and delineating the invariants from the variants usually leads to the construction of what is called a component framework system where the invariants form the framework and the variants constitute the components.

![Component framework](https://www.clear.rice.edu/comp310/JavaResources/frameworks/frameworks.png)

Hence, in essence, component-frameworks break the system down into variant "components" that represent abstract processing that the system supports. These components are generally thought of as "pluggable" in the sense that the system can be configured with a set of components to accomplish a particular task or set of tasks.   In many systems, the components can dynamically swapped in and out.   The framework, on the other hand, is the invariant "superstructure" that manages the components, providing services to each component that, when combined with the services/behaviors supplied by that component, create the net behavior defined by that component in that framework.    The framework has the effect of decoupling or isolating the components from each other since it the component interactions are handled by the framework in a manner that is opaque to the components.

## Benefits
As previously mentioned, the benefits are : 

- reuse, with the associated productivity gains
- composability
- maintainability
  - components can be replaced easily, by a better or equivalent version  
- reliability
  - in the measure that components and the component framework are properly tested and reliable, the surface area on which bugs can attach themselves is considerably lower

## Words of caution
The main goal of componentization which is reuse has however often proved elusive.
 
TODO put here the arguments from 70-SoftwareComponents and reusability - challenges
AND [Why Software Reuse has Failed and How to Make It Work for You](https://www.dre.vanderbilt.edu/~schmidt/reuse-lessons.html)
TODO move it somewhere adecaute

## Component framework
A component framework or platform provides both a systematic method to construct components, possibly from other components (namely dealing with interface, binding and interactions between components), and a systematic interface between component and the component framework, by which components can be analyzed, instantiated, destroyed, executed (namely dealing with component lifecycle)[^A classification framework for software component models].

![Component framework](https://i.imgur.com/mLozPJ4.png)

Componentization in our context is based on expressing the reactive function `f` as the combination of functions, each of which captures a smaller part of the overall `f`'s complexity. 

The bet is that :

- the smaller functions will lead to lower complexity, 
- that complexity will be low enough to be addressed satisfactorily at the smaller function level, 
- `f` can be recombined in a systematic way without loss in specification from the smaller functions
- it will be possible to encapsulate a large class of reactive subsystems into reusable generic components, which can then be parameterized to reflect the targeted reactive subsystem at hand. 

We will present what is a component in our framework, parallel and sequential composition of components, and their interaction with the framework.

### Component definition
TODO : basically stream sources or factories, settings -> output as action representation

### Sequential composition
We want `combine :: Array<Component> -> Component`, where :

- combine([f]) = f
- combine([f, g]) 
  - only defined when f and g have at least one matching output/input
  - connect input to output TODO show some diagram - ah already did
  - if not defined returns empty component, the component who does nothing OR ERROR??


### Parallel composition
In short, we want a `combine :: Array<Component> -> Component`, where :

- `f` the reactive function specified by the reactive system, can be expressed as a `Component`
- `f` can be obtained by applying `combine` to other reactive functions also expressed as `Component`, i.e.
	- `f = combine([f1, f2, f3...])`

Note that :

- the `combine` function can take any extra arguments, in which case, by uncurrying, it is always possible to come back the canonical `combine` form shown previously.   
- As any component used to derive another component can itself have been derived,   componentization naturally leads to the manipulation of component trees
	- `f = combine([f1, f2...])`
	- `f = combine([combine([f1.1, f1.2, f1.3...]), combine([f2.1, f2.2, f2.3...])...])`
	- etc.

There are usually many ways to perform that componentization. The idea in every case is to reach functions `fx.y.z...` whose complexity is easily manageable. If we understand that part of complexity of such `f...` emanates from `f`, while another part stems from the interaction of `f` with the larger reactive system, we see that there is a sweet spot where the function is 'small' enough to be manageable but not too small so it has to be coupled with many other `f...`s to achieve a given functionality (coupling increases complexity).

INSERT example

## cycle and my library
main pattern

f = InjectSourcesAndSettings(sourcesAndSettings, [f1,
  f1.1,
  f1.2,
  ...
]);

## Breakdown phase
`f` is componentized into (`f1, f1.1,...`) :

- `actions = f(states, events)`
- `actions1 = f1(states1, events1)`, where :
  - `f1` is derived from `f`'s specifications
   - `states1` is derived from `states` and `f1`'s specification
  - `events1` is derived from `states` and `f1`'s specification

### Genericity, parametricity and reuse
At the core of reusability of components is the ability to design components implementing a behaviour which is generic enough to cover a large set of contexts, and parameterizable enough to be customized at design-time or run-time without modification.

In this effort, we will address the parameterization concern with a specific parameter (often termed as `settings`) passed to the reusable component factories or combinators. For instance a `CheckBox` component implementing the generic reactive system made of a checkbox which when clicked emits an action including its checked/unchecked state,  could be written to be parameterized in appearance/style (allowing to customize the checkbox background for example).

Genericity at the component level is ad-hoc and can leverage the usual polymorphism techniques. INSERT example.

Component polymorphism and component customization work synergistically to provide a powerful reuse mechanism. This however naturally makes the life of the component designer more difficult, in order to make the life of the component user simpler.

In the frame of this componentization effort, passing settings to component is realized by `InjectSourcesAndSettings` combinator.

### Component adaptation
The states and events streams of `f1` are linked to those of `f`, by inheritance or transformation. ??TODO

- adapting the inputs
	- `InjectSources`
	- `InjectSourcesAndSettings`
- adapting the outputs
	- none for now, just in `ListOf` we have a `sinkname` mapping function, maybe that could be a setting in every combinator, i.e. another option for m?? but then I would need the symetric feature for mapping inputs, and then inputs and mapped inputs are both in settings, so do I remove the inputs and keep only the mapped inputs etc. to think about, it is not so simple, both case could be valid, and having both increase complexity and surface of API

## Example of specs as sequence [(event,action)]
Counter : input box = counter in DB, click -> increase counter and save in db
2 counters for 2 dbs, click increase both counters
- `actions = f(state, events)`
- `State :: (DB1_STATE, DB2_STATE)`
- `Events :: ButtonClick1 | ButtonClick2`
- f(state, click) -> Increase Db1State state, Increase Db2State state (2 actions)
	- f1 (DB1_STATE, ButtonClick1 )
	- f2(DB2_STATE, ButtonClick2)
	- f = f1+f2

So State -> focus -> lens
So Events -> choose -> prism

TODO : explain that better
INSERT example

SHOW how thermite framework, elm framework, cycle can be derived as variation on the reactive formulation

This reuse concept reduces
production cost as well as saves time by composing a system
from prebuilt or existing components, instead of building
them from scratch, these already prebuilt components can be
reused in many systems. 

An individual software component is a software package, a web service, a web resource, or a module that encapsulates a set of related functions (or data).
All system processes are placed into separate components so that all of the data and functions inside each component are semantically related (just as with the contents of classes). Because of this principle, it is often said that components are modular and cohesive.

“A software component is a unit of composition with
contractually specified interfaces and explicit context
dependencies only. A software component can be
deployed independently and is subject to composition
by third parties”

## thoughts on constant and variable part of the state
State may further be segmented into :

- constants : constants are passed through use of a segregated `settings` variable
- variable : the variable part of the state may be passed through what is coined as **behaviours** in Conall Eliott's FRP.

State is passed down the component hierarchy via `InjectSources`, `InjectSourcesAndSettings` combinators

**TODO** : clarify the whole/part relation of states. States here is a stream, so that will be a stream which is a tree of substates. It all comes down to the derivation relation : focus (sub state, i.e. lens) or extend (new state type, i.e. prism)
**TODO** :  actually the settings that I pass is because of the necessity to customize generic components (generic UI components for example). Are they also representing constant state?? To think about

## Recombining phase
`actions` is recombined through `actions1`, `actions1.1`, etc. and the help of `combine` operators.

In the particular case of the 'update screen' action, recombination is performed based on insertion markers, called slots (following the web component terminology). Those slots are marked via the `InSlot` combinator.

## Summary
In summary, reactive systems can be specified by means of a reactive function associating inputs to actions. That reactive function can be obtained by composition of reactive functions from smaller reactive systems. 

A good decomposition or factoring is one : 

- which ensures for each subsystem a reduction in complexity
(simpler specifications, smaller size of the reactive system, few interactions with other subsystems i.e. intercomponent dependency)
- which can be reassembled in a way that is easy to reason about and trace
- can be parameterized without modification (open-closed principle), so futures changes in the overall reactive system have a higher change to result mainly in changes in parameterization of subsystems.
- highly cohesive, loosely coupled to ensure adaptability : 80% of software engineering deals with maintaining or releasing new versions. The cost of redesigning each of such adoptable components (or replacing by a better component) must be minimized.

In our reactive system, `cyclejs` context, for component construction, simple functions are used, exposing a fixed interface, differentiating parameterization concern and dataflow concern in their inputs; a port metaphor is used for component sequential composition ; combinators are used for parallel composition. Component lifecycle is handled by the framework which by means of <em>start</em> and <em>stop</em> functionalities.
  
  TODO : talk about the combinator roles in the construction of component!!! talk about stream and dataflow that is an important part of the interface specification

## Bibliography
[Reducing Complexity in Software & Systems](https://www.sei.cmu.edu/podcasts/podcast_episode.cfm?episodeid=443886)

[Software Component Models - Component Life Cycle](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.450.9230&rep=rep1&type=pdf)
> The minimum criteria correspond to the definition of component models given in the introduction and in Section 2:
  1) A component model includes a component definition;
  2) A component model provides rules for component
  interoperability;
  3) Component functional properties are unambiguously specified by component interface;
  4) A component interface is used in the interoperability mechanisms;
  5) A component is an executable piece of software and
  the component model either directly specifies its
  form or unambiguously relates to it via interface
  and interoperability specification.

[Component Based Systems - 2011](http://www.win.tue.nl/~johanl/educ/2II45/ADS.09.CBSE.pdf)

[Component-Framework Systems](https://www.clear.rice.edu/comp310/JavaResources/frameworks)

[A Generic Component Framework for System Modeling](https://link.springer.com/content/pdf/10.1007/3-540-45923-5_3.pdf)
> In this sense, given a generic modeling technique with model specifications in the sense of 2.1, we are now able to define our generic component concept. A component specification, in short component, `COMP = (IMP, EXP, BOD, imp, exp)` consists of model specifications and connections:
> 
> – IMP, called import interface,
> – EXP, called export interface,
> – BOD, called body,
> – imp: IMP → BOD, called import connection,
> – exp: EXP → BOD, called export connection.

[A classification framework for software component models](https://pdfs.semanticscholar.org/04ab/304cd8102fdbecd6a41cde9a934e1567b1b3.pdf)

[Software Components: Only The Giants Survive]()70-SoftwareComponents and reusability - challenges
